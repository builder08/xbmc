/*
 *  Copyright (C) 2005-2018 Team Kodi
 *  This file is part of Kodi - https://kodi.tv
 *
 *  SPDX-License-Identifier: GPL-2.0-or-later
 *  See LICENSES/README.md for more information.
 */

#include "utils/CharsetConverter.h"
#include "utils/StringUtils.h"
#include "utils/UnicodeConverter.h"

#include <chrono>
#include <iomanip>
#include <iostream>
#include <string_view>

#include <gtest/gtest.h>

using namespace std::literals;
using namespace std::chrono_literals;

#if defined(TARGET_DARWIN)
constexpr bool IS_DARWIN{true};
#else
constexpr bool IS_DARWIN{false};
#endif

namespace
{
static constexpr std::string_view UTF8_SUBSTITUTE_CHARACTER{"\xef\xbf\xbd"sv};
// static constexpr std::wstring_view WCHAR_T_SUBSTITUTE_CHARACTER{L"\xfffd"sv};
static constexpr std::u32string_view CHAR32_T_SUBSTITUTE_CHARACTER{U"\x0000fffd"sv}; //U'ï¿½'sv
static constexpr bool REPORT_PERFORMANCE_DETAILS{true};

static int Compare(const std::u32string_view str1,
                   const std::u32string_view str2,
                   const size_t n = 0)
{
  // n is the maximum number of Unicode codepoints (for practical purposes
  // equivalent to characters).
  //
  // Much better to avoid using n by using StartsWith or EndsWith, etc.
  //
  // if n == 0, then do simple utf8 compare
  //
  // Otherwise, convert to Unicode then compare codepoints.
  //

  if (n == 0)
    return str1.compare(str2);

  return str1.compare(0, n, str2, 0, n);
}

static int Compare(const std::wstring_view str1, const std::wstring_view str2, const size_t n = 0)
{
  // n is the maximum number of Unicode codepoints (for practical purposes
  // equivalent to characters).
  //
  // Much better to avoid using n by using StartsWith or EndsWith, etc.
  //
  // if n == 0, then do simple utf8 compare
  //
  // Otherwise, convert to Unicode then compare, then compare codepoints.
  //

  if (n == 0)
    return str1.compare(str2);

  // Have to convert to Unicode codepoints

  std::u32string utf32Str1 = StringUtils::ToUtf32(str1);
  std::u32string utf32Str2 = StringUtils::ToUtf32(str2);

  return utf32Str1.compare(0, n, utf32Str2, 0, n);
}

static bool Equals(const std::string_view str1, const std::string_view str2)
{
  return StringUtils::Equals(str1, str2);
}

static bool Equals(const std::u32string_view str1, const std::u32string_view str2)
{
  return Compare(str1, str2) == 0;
}

static bool Equals(const std::wstring_view str1, const std::wstring_view str2)
{
  return Compare(str1, str2) == 0;
}

TEST(TestCUnicodeConverter, utf8ToUtf32)
{
  std::string_view simpleTest{"This is a simpleTest"};
  std::wstring_view wSimpleTest{L"This is a simpleTest"};
  std::u32string_view u32SimpleTest{U"This is a simpleTest"};

  std::u32string u32Result = CUnicodeConverter::Utf8ToUtf32("This is a simpleTest"sv);
  EXPECT_TRUE(Equals(u32Result, u32SimpleTest));

  std::wstring wResult = CUnicodeConverter::Utf8ToW(simpleTest);
  EXPECT_TRUE(Equals(wResult, wSimpleTest));

  std::string utf8Result = CUnicodeConverter::Utf32ToUtf8(u32Result);
  EXPECT_TRUE(Equals(simpleTest, utf8Result));

  utf8Result = CUnicodeConverter::WToUtf8(wSimpleTest);
  EXPECT_TRUE(Equals(simpleTest, utf8Result));

  wResult = CUnicodeConverter::Utf32ToW(u32SimpleTest);
  EXPECT_TRUE(Equals(wSimpleTest, wResult));

  u32Result = CUnicodeConverter::WToUtf32(wSimpleTest);
  EXPECT_TRUE(Equals(u32SimpleTest, u32Result));
}

TEST(TestCUnicodeConverter, BadUnicode)
{
  // Verify that code doesn't crater on malformed/bad Unicode. Is NOT an exhaustive
  // list.

  // Unassigned, private use or surrogates
  // Most do not trigger an error in wstring_convert (the Bad_UTF8 ones do).

  /*   static const char32_t BAD_CHARS[] = {
   U'\xFDD0',   U'\xFDEF',  U'\xFFFE',  U'\xFFFF',  U'\x1FFFE', U'\x1FFFF', U'\x2FFFE',
   U'\x2FFFF',  U'\x3FFFE', U'\x3FFFF', U'\x4FFFE', U'\x4FFFF', U'\x5FFFE', U'\x5FFFF',
   U'\x6FFFE',  U'\x6FFFF', U'\x7FFFE', U'\x7FFFF', U'\x8FFFE', U'\x8FFFF', U'\x9FFFE',
   U'\x9FFFF',  U'\xAFFFE', U'\xAFFFF', U'\xBFFFE', U'\xBFFFF', U'\xCFFFE', U'\xCFFFF',
   U'\xDFFFE',  U'\xDFFFF', U'\xEFFFE', U'\xEFFFF', U'\xFFFFE', U'\xFFFFF', U'\x10FFFE',
   U'\x10FFFF'};

   for (char32_t c : BAD_CHARS)
   {
   std::u32string s(1, c);
   std::string utf8str = CUnicodeConverter::Utf32ToUtf8(s);

   std::cout << "u32string: " << StringUtils::ToHex(s)  << " utf8: " << utf8str <<
   " " << StringUtils::ToHex(utf8str) << " sub: " << UTF8_SUBSTITUTE_CHARACTER
   << " " << StringUtils::ToHex(UTF8_SUBSTITUTE_CHARACTER) << std::endl;

   EXPECT_TRUE(StringUtils::Equals(utf8str, UTF8_SUBSTITUTE_CHARACTER));
   }
   EXPECT_TRUE(true);  */

  static const char32_t REPLACED_CHARS[] = {U'\x0D800', U'\x0D801', U'\x0D802', U'\x0D803',
                                            U'\x0D804', U'\x0D805', U'\xDB7F',  U'\xDB80',
                                            U'\xDBFF',  U'\xDC00',  U'\x0DFFF'};

  for (char32_t c : REPLACED_CHARS)
  {
    std::u32string s(1, c);
    std::string utf8str = CUnicodeConverter::Utf32ToUtf8(s);
    EXPECT_TRUE(StringUtils::Equals(utf8str, UTF8_SUBSTITUTE_CHARACTER));

    // std::cout << "Bad Char: " << std::hex << s[0] << " converted to UTF8: "
    //     << std::hex << utf8str
    //    << " expected: " << std::hex << UTF8_SUBSTITUTE_CHARACTER << std::endl;
  }
  EXPECT_TRUE(true);
  // More problems should show up with multi-byte utf8 characters missing the
  // first byte.

  static const std::string BAD_UTF8[] = {
      "\xcc"s, "\xb3"s, "\x9f"s, "\xab"s, "\x93", "\x8b",
  };
  for (std::string str : BAD_UTF8)
  {
    // std::cout << std::hex << str[0] << " utf8: " << str << std::endl;
    std::u32string trash = StringUtils::ToUtf32(str);
    EXPECT_EQ(trash[0], CHAR32_T_SUBSTITUTE_CHARACTER[0]);
    EXPECT_EQ(Compare(trash, CHAR32_T_SUBSTITUTE_CHARACTER), 0);
  }
  EXPECT_TRUE(true);

  // TODO: These are single char tests. Add more advanced tests:
  // First char in multi-char string bad
  // Last char in multi-char string bad
  // Next to last char bad
  // second char bad
  // Every other char bad with first and last bad
  // Every other char bad with second and next to last char bad
  // Multiple consecutive bad chars at start, end, middle and next to end of string
  // Include wchar_t
}

TEST(TestCUnicodeConverter, SubstituteStart)
{
  bool testPassed;

  // badStartUTF8 is a string that starts with an invalid utf8 code-unit
  //
  // Convert it to wstring and u32string and verify that this results in
  // the first code-unit in each being the substitution character.
  // Also, covert both converted wstring and u32string (with substitution char)
  // back to utf8 and verify that it has a substitution char.

  std::string_view badStartUTF8{"\xcc"sv
                                "This is a simpleTest"sv};

  // std::cout << "badStartUTF8: " << badStartUTF8 << " Hex: " << StringUtils::ToHex(badStartUTF8) << std::endl;

  std::string_view utf8ExpectedResult{"\xef\xbf\xbdThis is a simpleTest"};
  std::wstring_view wExpectedResult{L"\x0fffdThis is a simpleTest"};
  std::u32string_view u32ExpectedResult{U"\x0fffdThis is a simpleTest"};

  std::u32string u32Result = CUnicodeConverter::Utf8ToUtf32(badStartUTF8);
  //std::cout << "u32Result: " << StringUtils::ToHex(u32Result)  << " utf8: " << badStartUTF8 <<
  //       " " << StringUtils::ToHex(badStartUTF8) << " sub: " << UTF8_SUBSTITUTE_CHARACTER
  //        << " " << StringUtils::ToHex(UTF8_SUBSTITUTE_CHARACTER) << std::endl;

  EXPECT_TRUE(Equals(u32Result, u32ExpectedResult));

  std::wstring wResult = CUnicodeConverter::Utf8ToW(badStartUTF8);
  EXPECT_TRUE(Equals(wResult, wExpectedResult));

  // Convert both wstring and u32string (with substitution code-unit, from above)
  // back to utf8

  std::string utf8Result = CUnicodeConverter::Utf32ToUtf8(u32Result);
  EXPECT_TRUE(StringUtils::Equals(utf8Result, utf8ExpectedResult));

  utf8Result = CUnicodeConverter::WToUtf8(wResult);
  EXPECT_TRUE(StringUtils::Equals(utf8Result, utf8ExpectedResult));

  // Now verify that a bad first codeunit for wstring and u32string
  // produce substitution char when converting to string

  std::u32string_view badStartUtf32{U"\x0D800This is a simpleTest"};
  utf8Result = CUnicodeConverter::Utf32ToUtf8(badStartUtf32);
  testPassed = Equals(u32Result, u32ExpectedResult);

  if (!testPassed)
  {
    std::cout << "badStartUtf32: "
              << " Hex: " << StringUtils::ToHex(badStartUtf32) << std::endl;
    std::cout << "utf8Result: " << utf8Result << " Hex: " << StringUtils::ToHex(utf8Result)
              << std::endl;
  }
  EXPECT_TRUE(testPassed);

  testPassed = StringUtils::Equals(utf8Result, utf8ExpectedResult);
  if (!testPassed)
  {
    utf8Result = CUnicodeConverter::WToUtf8(wExpectedResult);
    std::cout << "badStartUtf32: "
              << " Hex: " << StringUtils::ToHex(badStartUtf32) << std::endl;
    std::cout << "utf8Result: " << utf8Result << " Hex: " << StringUtils::ToHex(utf8Result)
              << std::endl;
  }
  EXPECT_TRUE(testPassed);
}

TEST(TestCUnicodeConverter, SubstituteEnd)
{
  // badEndUTF8 is a string that ends with an invalid utf8 code-unit
  //
  // Convert it to wstring and u32string and verify that this results in
  // the last code-unit in each being the substitution character.
  // Also, convert both converted wstring and u32string (with substitution char)
  // back to utf8 and verify that it has a substitution char.

  // Mac OSX iconv appears to have a bug. If last utf-8 (perhaps more) character
  // is malformed, then it marks the character before it also as bad.

  if (!IS_DARWIN)
  {
    std::string_view badEndUTF8{"This is a simpleTest\x9f"sv};

    std::string_view utf8ExpectedResult{"This is a simpleTest\xef\xbf\xbd"};
    std::wstring_view wExpectedResult{L"This is a simpleTest\x0fffd"};
    std::u32string_view u32ExpectedResult{U"This is a simpleTest\x0fffd"};

    std::u32string u32Result = CUnicodeConverter::Utf8ToUtf32(badEndUTF8);

    bool testPassed = Equals(u32Result, u32ExpectedResult);
    if (!testPassed)
    {
      // FYI: Maximum codepoint supported by OSX is around FF50;

      std::cout << " FAIL 1: utf8: " << badEndUTF8 << " " << StringUtils::ToHex(badEndUTF8)
                << std::endl;

      std::cout << "u32Result: " << StringUtils::ToHex(u32Result) << std::endl;
      std::cout << "u32ExpectedResult: " << StringUtils::ToHex(u32ExpectedResult) << std::endl
                << std::endl;
    }
    EXPECT_TRUE(testPassed);

    std::wstring wResult = CUnicodeConverter::Utf8ToW(badEndUTF8);
    testPassed = Equals(wResult, wExpectedResult);
    if (!testPassed)
    {
      // Maximum codepoint supported by the OSX is around FF50;
      std::cout << " FAIL 2: utf8: " << badEndUTF8 << " " << StringUtils::ToHex(badEndUTF8)
                << std::endl;

      std::cout << "wResult: " << StringUtils::ToHex(wResult) << std::endl;
      std::cout << "u32Result: " << StringUtils::ToHex(u32ExpectedResult) << std::endl << std::endl;
    }
    EXPECT_TRUE(testPassed);

    // Convert both wstring and u32string (with substitution code-unit, from above)
    // back to utf8

    std::string utf8Result = CUnicodeConverter::Utf32ToUtf8(u32Result);
    EXPECT_TRUE(StringUtils::Equals(utf8Result, utf8ExpectedResult));

    utf8Result = CUnicodeConverter::WToUtf8(wResult);
    EXPECT_TRUE(StringUtils::Equals(utf8Result, utf8ExpectedResult));

    // ==========================
    // Now verify that a bad last codeunit for wstring and u32string
    // produce substitution char when converting to string

    // std::wstring_view badEndW{L"This is a simpleTest\x0D800"};
    std::u32string_view badEndUtf32{U"This is a simpleTest\x0D800"};

    utf8Result = CUnicodeConverter::Utf32ToUtf8(badEndUtf32);
    EXPECT_TRUE(StringUtils::Equals(utf8Result, utf8ExpectedResult));

    utf8Result = CUnicodeConverter::WToUtf8(wExpectedResult);
    EXPECT_TRUE(StringUtils::Equals(utf8Result, utf8ExpectedResult));
  }
  // Repeat above experiment, but bad char will be next to the last char

  {
    std::string_view badEndUTF8{"This is a simpleTest \x9f."sv};
    std::string_view utf8ExpectedResult{"This is a simpleTest \xef\xbf\xbd."};
    std::wstring_view wExpectedResult;
    std::u32string_view u32ExpectedResult;
    if (!IS_DARWIN)
    {
      u32ExpectedResult = U"This is a simpleTest \x0fffd."sv;
      wExpectedResult = L"This is a simpleTest \x0fffd."sv;
    }
    else
    {
      // No space, two substitutions
      u32ExpectedResult = U"This is a simpleTest\x0fffd\x0fffd."sv;
      wExpectedResult = L"This is a simpleTest\x0fffd\x0fffd."sv;
    }
    std::u32string u32Result = CUnicodeConverter::Utf8ToUtf32(badEndUTF8);
    bool testPassed = Equals(u32Result, u32ExpectedResult);
    if (!testPassed)
    {
      // Maximum codepoint supported by the OSX that we are using
      // is around FF50;
      std::cout << " FAIL 3: utf8: " << badEndUTF8 << " " << StringUtils::ToHex(badEndUTF8)
                << std::endl;

      std::cout << "u32Result: " << StringUtils::ToHex(u32Result) << std::endl;
      std::cout << "u32ExpectedResult: " << StringUtils::ToHex(u32ExpectedResult) << std::endl
                << std::endl;
    }
    // if (!IS_DARWIN)
    //  EXPECT_TRUE(testPassed);

    std::wstring wResult = CUnicodeConverter::Utf8ToW(badEndUTF8);
    testPassed = Equals(wResult, wExpectedResult);
    if (!testPassed)
    {
      // Maximum codepoint supported by the OSX that we are using
      // is around FF50;
      std::cout << " FAIL 4: utf8: " << badEndUTF8 << " " << StringUtils::ToHex(badEndUTF8)
                << std::endl;

      std::cout << "wResult: " << StringUtils::ToHex(wResult) << std::endl;
      std::cout << "wExpectedResult: " << StringUtils::ToHex(wExpectedResult) << std::endl
                << std::endl;
    }
    if (!IS_DARWIN)
    {
      EXPECT_TRUE(testPassed);
    }
    if (IS_DARWIN)
    {
      // OSX, same as before.
      utf8ExpectedResult = "This is a simpleTest\0xef\0xbf\0xbd\0xef\0xbf\0xbd."s;
    }
    // Convert both wstring and u32string (with substitution code-unit, from above)
    // back to utf8

    std::string utf8Result = CUnicodeConverter::Utf32ToUtf8(u32Result);
    testPassed = Equals(utf8Result, utf8ExpectedResult);
    if (!testPassed)
    {
      // Maximum codepoint supported by the OSX that we are using
      // is around FF50;
      std::cout << " FAIL 5: input- u32Result: " << StringUtils::ToHex(u32Result) << std::endl;

      std::cout << "utf8Result: " << StringUtils::ToHex(utf8Result) << std::endl;
      std::cout << "utf8ExpectedResult: " << StringUtils::ToHex(utf8ExpectedResult) << std::endl
                << std::endl;
    }
    if (!IS_DARWIN)
    {
      EXPECT_TRUE(testPassed);
    }
    utf8Result = CUnicodeConverter::WToUtf8(wResult);
    testPassed = Equals(utf8Result, utf8ExpectedResult);
    if (!testPassed)
    {
      // Maximum codepoint supported by the OSX that we are using
      // is around FF50;
      std::cout << " FAIL 6: input- wResult: " << StringUtils::ToHex(wResult) << std::endl;

      std::cout << "wResult: " << StringUtils::ToHex(wResult) << std::endl;
      std::cout << "utf8ExpectedResult: " << StringUtils::ToHex(utf8ExpectedResult) << std::endl
                << std::endl;
    }
    if (!IS_DARWIN)
    {
      EXPECT_TRUE(testPassed);
    }

    // Now verify that a bad last codeunit for wstring and u32string
    // produce substitution char when converting to string

    std::u32string_view badEndUtf32{U"This is a simpleTest \x0D800."};
    utf8Result = CUnicodeConverter::Utf32ToUtf8(badEndUtf32);
    testPassed = StringUtils::Equals(utf8Result, utf8ExpectedResult);
    if (!testPassed)
    {
      // Maximum codepoint supported by the OSX that we are using
      // is around FF50;
      std::cout << " FAIL 7: badEndUtf32: " << StringUtils::ToHex(badEndUtf32) << std::endl;

      std::cout << "utf8Result: " << StringUtils::ToHex(utf8Result) << std::endl;
      std::cout << "utf8ExpectedResult: " << StringUtils::ToHex(utf8ExpectedResult) << std::endl
                << std::endl;
    }
    if (!IS_DARWIN)
    {
      EXPECT_TRUE(testPassed);
    }
    utf8Result = CUnicodeConverter::WToUtf8(wResult);
    testPassed = StringUtils::Equals(utf8Result, utf8ExpectedResult);
    if (!testPassed)
    {
      // Maximum codepoint supported by the OSX that we are using
      // is around FF50;
      std::cout << " FAIL8 : wResult: " << StringUtils::ToHex(wResult) << std::endl;

      std::cout << "utf8Result: " << StringUtils::ToHex(utf8Result) << std::endl;
      std::cout << "utf8ExpectedResult: " << StringUtils::ToHex(utf8ExpectedResult) << std::endl
                << std::endl;
    }
    if (!IS_DARWIN)
    {
      EXPECT_TRUE(testPassed);
    }
  }
}

TEST(TestCUnicodeConverter, SubstituteMiddle)
{
  if (IS_DARWIN)
  {
    return;
  }

  // Convert it to wstring and u32string and verify that this results in
  // the middle bad code-unit in each being the substitution character.
  // Also, covert both converted wstring and u32string (with substitution char)
  // back to utf8 and verify that it has a substitution char.

  std::string_view badMiddleUTF8{"This is a\xcc simpleTest"sv};
  std::string_view utf8ExpectedResult{"This is a\xef\xbf\xbd simpleTest"};
  std::wstring_view wExpectedResult{L"This is a\x0fffd simpleTest"};
  std::u32string_view u32ExpectedResult{U"This is a\x0fffd simpleTest"};

  // DARWIN appears buggy

  if (IS_DARWIN)
  {
    badMiddleUTF8 = "This is a\xcc simpleTest"sv;
    utf8ExpectedResult = "This is \xef\xbf\xbd\xef\xbf\xbd simpleTest";
    wExpectedResult = L"This is \x0fffd\x0fffd simpleTest";
    u32ExpectedResult = U"This is \x0fffd\x0fffd simpleTest";
  }
  std::u32string u32Result = CUnicodeConverter::Utf8ToUtf32(badMiddleUTF8);

  bool testPassed = Equals(u32Result, u32ExpectedResult);
  if (!testPassed)
  {
    std::cout << "badMiddleUTF8: " << badMiddleUTF8 << " Hex: " << StringUtils::ToHex(badMiddleUTF8)
              << std::endl;
    std::cout << "u32Result: " << StringUtils::ToHex(u32Result) << " utf8: " << badMiddleUTF8 << " "
              << StringUtils::ToHex(badMiddleUTF8) << " sub: " << UTF8_SUBSTITUTE_CHARACTER << " "
              << StringUtils::ToHex(UTF8_SUBSTITUTE_CHARACTER) << std::endl;
  }
  EXPECT_TRUE(testPassed);

  std::wstring wResult = CUnicodeConverter::Utf8ToW(badMiddleUTF8);
  testPassed = Equals(wResult, wExpectedResult);
  if (!testPassed)
  {
    std::cout << "badMiddleUTF8: " << badMiddleUTF8 << " Hex: " << StringUtils::ToHex(badMiddleUTF8)
              << std::endl;
    std::cout << "u32Result: " << StringUtils::ToHex(wResult) << std::endl;
    std::cout << " wExpectedResult: " << StringUtils::ToHex(wExpectedResult) << std::endl;
  }
  EXPECT_TRUE(testPassed);

  // Convert both wstring and u32string (with substitution code-unit, from above)
  // back to utf8

  std::string utf8Result = CUnicodeConverter::Utf32ToUtf8(u32Result);
  testPassed = StringUtils::Equals(utf8Result, utf8ExpectedResult);

  EXPECT_TRUE(testPassed);

  utf8Result = CUnicodeConverter::WToUtf8(wResult);
  testPassed = StringUtils::Equals(utf8Result, utf8ExpectedResult);

  EXPECT_TRUE(testPassed);

  // Now verify that a bad first codeunit for wstring and u32string
  // produce substitution char when converting to string

  // std::wstring_view badMiddleW{L"This is a\x0D800 simpleTest"};
  std::u32string_view badMiddleUtf32{U"This is a\x0D800 simpleTest"};
  utf8Result = CUnicodeConverter::Utf32ToUtf8(badMiddleUtf32);

  testPassed = StringUtils::Equals(utf8Result, utf8ExpectedResult);
  if (!testPassed)
  {
    std::cout << "badMiddleUtf32: "
              << " Hex: " << StringUtils::ToHex(badMiddleUtf32) << std::endl;
    std::cout << "utf8Result: " << utf8Result << " Hex: " << StringUtils::ToHex(utf8Result)
              << std::endl;
  }
  EXPECT_TRUE(testPassed);

  utf8Result = CUnicodeConverter::WToUtf8(wExpectedResult);
  testPassed = StringUtils::Equals(utf8Result, utf8ExpectedResult);
  if (!testPassed)
  {
    std::cout << "badMiddleUtf32: "
              << " Hex: " << StringUtils::ToHex(badMiddleUtf32) << std::endl;
    std::cout << "utf8Result: " << utf8Result << " Hex: " << StringUtils::ToHex(utf8Result)
              << std::endl;
  }
  EXPECT_TRUE(testPassed);
}

TEST(TestCUnicodeConverter, SubstituteStart2)
{
  // Convert it to wstring and u32string and verify that this results in
  // consecutive bad code-units being replaced with a single substitution
  // codepoint . This occurs even if the two malformed code-units
  // belong to different malformed codepoints.
  // Also, covert both converted wstring and u32string (with substitution char)
  // back to utf8 and verify that it has a substitution char.

  bool testPassed;
  std::string_view badStart2UTF8{"\xcc\xcdThis is a simpleTest"sv};
  std::string_view utf8ExpectedResult{"\xef\xbf\xbdThis is a simpleTest"};
  std::wstring_view wExpectedResult{L"\x0fffdThis is a simpleTest"};
  std::u32string_view u32ExpectedResult{U"\x0fffdThis is a simpleTest"};

  std::u32string u32Result = CUnicodeConverter::Utf8ToUtf32(badStart2UTF8);
  testPassed = Equals(u32Result, u32ExpectedResult);
  if (!testPassed)
  {
    std::cout << "u32Result: " << StringUtils::ToHex(u32Result) << " utf8: " << badStart2UTF8 << " "
              << StringUtils::ToHex(badStart2UTF8) << " sub: " << UTF8_SUBSTITUTE_CHARACTER << " "
              << StringUtils::ToHex(UTF8_SUBSTITUTE_CHARACTER) << std::endl;
  }
  EXPECT_TRUE(testPassed);

  std::wstring wResult = CUnicodeConverter::Utf8ToW(badStart2UTF8);
  EXPECT_TRUE(Equals(wResult, wExpectedResult));

  // Convert both wstring and u32string (with substitution code-unit, from above)
  // back to utf8

  std::string utf8Result = CUnicodeConverter::Utf32ToUtf8(u32Result);
  EXPECT_TRUE(StringUtils::Equals(utf8Result, utf8ExpectedResult));

  utf8Result = CUnicodeConverter::WToUtf8(wResult);
  EXPECT_TRUE(StringUtils::Equals(utf8Result, utf8ExpectedResult));

  // Now verify that a bad first codeunit for wstring and u32string
  // produce substitution char when converting to string

  // std::wstring_view badStart2W{L"\x0D800\x0D801This is a simpleTest"};
  std::u32string_view badStart2Utf32{U"\x0D800\x0D801This is a simpleTest"};
  utf8Result = CUnicodeConverter::Utf32ToUtf8(badStart2Utf32);

  testPassed = StringUtils::Equals(utf8Result, utf8ExpectedResult);
  if (!testPassed)
  {
    std::cout << "badStart2Utf32: "
              << " Hex: " << StringUtils::ToHex(badStart2Utf32) << std::endl;
    std::cout << "utf8Result: " << utf8Result << " Hex: " << StringUtils::ToHex(utf8Result)
              << std::endl;
  }
  EXPECT_TRUE(testPassed);

  utf8Result = CUnicodeConverter::WToUtf8(wExpectedResult);
  testPassed = StringUtils::Equals(utf8Result, utf8ExpectedResult);
  if (!testPassed)
  {
    std::cout << "badStart2Utf32: "
              << " Hex: " << StringUtils::ToHex(badStart2Utf32) << std::endl;
    std::cout << "utf8Result: " << utf8Result << " Hex: " << StringUtils::ToHex(utf8Result)
              << std::endl;
  }
  EXPECT_TRUE(testPassed);
}

TEST(TestCUnicodeConverter, SubstituteMulti)
{
  if (IS_DARWIN)
  {
    return;
  }

  // This tests having multiple bad chars within a string

  // Test with UTF8 malformed character sequence: 2 bad codepoints in a row. Both have
  // proper start bytes, but invalid middle bytes. This sequence will show
  // up at beginning, middle and end of same string.

  bool testPassed;

  std::string_view badStart2UTF8{
      "\xcc\xd0\xc5\xd1\xd2\xd3\xcdThis is \xcc\xd0\xc5\xd1\xd3\xcd a simpleTest\xcc\xd0\xd1\xd2\xd3\xcd"sv};

  std::string_view utf8ExpectedResult{"\xef\xbf\xbdThis is \xef\xbf\xbd a "
                                      "simpleTest\xef\xbf\xbd"};
  std::wstring_view wExpectedResult{L"\x0fffdThis is \x0fffd a simpleTest\x0fffd"};
  std::u32string_view u32ExpectedResult{U"\x0fffdThis is \x0fffd a simpleTest\x0fffd"};

  std::u32string u32Result = CUnicodeConverter::Utf8ToUtf32(badStart2UTF8);
  testPassed = Equals(u32Result, u32ExpectedResult);
  if (!testPassed)
  {
    std::cout << "u32Result: " << StringUtils::ToHex(u32Result) << " utf8: " << badStart2UTF8 << " "
              << StringUtils::ToHex(badStart2UTF8) << " sub: " << UTF8_SUBSTITUTE_CHARACTER << " "
              << StringUtils::ToHex(UTF8_SUBSTITUTE_CHARACTER) << std::endl;
  }
  EXPECT_TRUE(testPassed);

  std::wstring wResult = CUnicodeConverter::Utf8ToW(badStart2UTF8);
  EXPECT_TRUE(Equals(wResult, wExpectedResult));

  // Convert both wstring and u32string (with substitution code-unit, from above)
  // back to utf8

  std::string utf8Result = CUnicodeConverter::Utf32ToUtf8(u32Result);
  EXPECT_TRUE(StringUtils::Equals(utf8Result, utf8ExpectedResult));

  utf8Result = CUnicodeConverter::WToUtf8(wResult);
  EXPECT_TRUE(StringUtils::Equals(utf8Result, utf8ExpectedResult));
}

TEST(TestCUnicodeConverter, SkipMulti)
{
  //if (IS_DARWIN)
  //  return;

  // This test is based on SubstituteMulti, but rather than substituting bad
  // chars with the subsitution character, here we omit the bad characters
  // from the conversion.

  bool testPassed;

  std::string_view badStart2UTF8{
      "\xcc\xd0\xc5\xd1\xd2\xd3\xcdThis is \xcc\xd0\xc5\xd1\xd3\xcd a simpleTest\xcc\xd0\xd1\xd2\xd3\xcd"sv};
  std::wstring_view badStart2W{L"\x0D800\x0D801This is a simple\x0D801Test"};
  std::u32string_view badStart2Utf32{U"\x0D800\x0D801This is a simple\x0D801Test"};

  std::string_view utf8ExpectedResult{"This is  a simpleTest"};
  std::wstring_view wExpectedResult{L"This is  a simpleTest"};

  // OSX Omits a second space and final 't'
  std::wstring_view osx_wExpectedResult{L"This is a simpleTes"};

  std::u32string_view u32ExpectedResult{U"This is  a simpleTest"};

  // OSX Omits a second space and final 't'
  std::u32string_view osx_u32ExpectedResult{U"This is a simpleTes"};

  std::u32string u32Result = CUnicodeConverter::Utf8ToUtf32(badStart2UTF8, false, false);

  if (IS_DARWIN)
  {
    u32ExpectedResult = osx_u32ExpectedResult;
  }
  testPassed = Equals(u32Result, u32ExpectedResult);
  if (!testPassed)
  {
    std::cout << "FAIL 1 u32Result: " << StringUtils::ToHex(u32Result) << std::endl;
    std::cout << "utf8: " << badStart2UTF8 << " " << StringUtils::ToHex(badStart2UTF8) << std::endl;
  }
  if (!IS_DARWIN || testPassed)
  {
    EXPECT_TRUE(testPassed); // FAILS ON OSX
  }
  if (IS_DARWIN && !testPassed)
  {
    GTEST_SKIP();
  }

  if (IS_DARWIN)
  {
    wExpectedResult = osx_wExpectedResult;
  }
  std::wstring wResult = CUnicodeConverter::Utf8ToW(badStart2UTF8, false, false);
  testPassed = Equals(wResult, wExpectedResult);
  if (!IS_DARWIN || testPassed)
  {
    EXPECT_TRUE(testPassed); // FAILS ON OSX
  }
  utf8ExpectedResult = "This is a simpleTest";
  std::string utf8Result = CUnicodeConverter::Utf32ToUtf8(badStart2Utf32, false, false);
  testPassed = StringUtils::Equals(utf8Result, utf8ExpectedResult);
  if (!IS_DARWIN || testPassed)
    EXPECT_TRUE(testPassed);

  utf8Result = CUnicodeConverter::WToUtf8(badStart2W, false, false);
  testPassed = StringUtils::Equals(utf8Result, utf8ExpectedResult);
  if (!IS_DARWIN || testPassed)
  {
    EXPECT_TRUE(testPassed);
  }
}

TEST(TestCUnicodeConverter, FailOnError)
{
  // Empty string is returned on any error with failOnInvalidChar=true

  // if (IS_DARWIN)
  //  return;

  // This test is based on SubstituteMulti, but rather than substituting bad
  // chars with the subsitution character, here the conversion stops on first
  // bad char, resulting in truncated substitution.

  bool testPassed;

  std::string_view badStart2UTF8{
      "\xcc\xd0\xc5\xd1\xd2\xd3\xcdThis is \xcc\xd0\xc5\xd1\xd3\xcd a simpleTest\xcc\xd0\xd1\xd2\xd3\xcd"sv};
  std::wstring_view badStart2W{L"This is a simple Test\x0D801"};
  std::u32string_view badStart2Utf32{U"This is a simple\x0D801Test"};
  std::string_view utf8ExpectedResult{""};
  std::wstring_view wExpectedResult{L""};
  std::u32string_view u32ExpectedResult{U""};

  std::u32string u32Result = CUnicodeConverter::Utf8ToUtf32(badStart2UTF8, true, false);
  testPassed = Equals(u32Result, u32ExpectedResult);
  if (!testPassed)
  {
    std::cout << "u32Result: " << StringUtils::ToHex(u32Result) << " utf8: " << badStart2UTF8 << " "
              << StringUtils::ToHex(badStart2UTF8) << " sub: " << UTF8_SUBSTITUTE_CHARACTER << " "
              << StringUtils::ToHex(UTF8_SUBSTITUTE_CHARACTER) << std::endl;
  }
  EXPECT_TRUE(testPassed);

  std::wstring wResult = CUnicodeConverter::Utf8ToW(badStart2UTF8, true, false);
  EXPECT_TRUE(Equals(wResult, wExpectedResult));

  std::string utf8Result = CUnicodeConverter::Utf32ToUtf8(badStart2Utf32, true, false);
  EXPECT_TRUE(StringUtils::Equals(utf8Result, utf8ExpectedResult));

  utf8Result = CUnicodeConverter::WToUtf8(badStart2W, true, false);

  testPassed = StringUtils::Equals(utf8Result, utf8ExpectedResult);
  if (!testPassed)
  {
    std::cout << "input: " << StringUtils::ToHex(badStart2W) << " utf8: " << badStart2UTF8
              << std::endl;
    std::cout << "output: " << StringUtils::ToHex(utf8Result) << " utf8: " << utf8Result
              << std::endl;
    std::cout << " expected: " << StringUtils::ToHex(utf8ExpectedResult)
              << " utf8: " << utf8ExpectedResult << std::endl;
  }
  EXPECT_TRUE(testPassed);
}

void runTest(int iterations,
             std::string_view title,
             std::string_view text,
             int expectedImprovement,
             int& actualImprovement,
             int& aggregateUnicodeConverterTime,
             int& aggregateCharsetConverterTime,
             bool endGroup = false,
             bool printSummary = false);

template<class T>
std::string FormatWithCommas(T value)
{
  std::stringstream ss;
  std::locale myLocale("en_GB.UTF-8");
  ss.imbue(myLocale);
  ss << std::fixed << (value);
  return ss.str();
}

TEST(TestCUnicodeConverter, Performance)
{
  // Confirm that performance no worse than CCharsetConverter
  //
  // This converter has several performance improvements over CCharsetConverter
  // The improvements are most apparent on shorter strings. Most strings are short
  // With optimized code:
  //   short strings are typically 56% faster
  //   medium strings 37% faster
  //   long strings 6% faster

  std::string shortString{"House"};
  std::string shortGermanString{"Haus"};
  std::string shortUkranianString{"ÐÑÐ¼"};
  std::string shortJapaneseString{"å®¶"};
  std::string mediumString{"Medium sized string about a sentence long."};
  std::string mediumGermanString{"MittelgroÃe Zeichenfolge um einen Satz lang"};
  std::string mediumUkranianString{"Ð ÑÐ´Ð¾Ðº ÑÐµÑÐµÐ´Ð½ÑÐ¾Ð³Ð¾ ÑÐ¾Ð·Ð¼ÑÑÑ Ð¿ÑÐ¾ Ð´Ð¾Ð²Ð³Ðµ ÑÐµÑÐµÐ½Ð½Ñ"};
  std::string mediumJapaneseString{"æã®é·ãã«é¢ããä¸­ãµã¤ãºã®æå­å"};

  std::string longString{
      "Four score and seven years ago our fathers brought "
      "forth on this continent, a new nation, conceived in Liberty, and dedicated "
      "to the proposition that all men are created equal.\n\n"
      "Now we are engaged in a great civil war, testing whether that nation, or any "
      "nation so conceived and so dedicated, can long endure. We are met on a "
      "great battle-field of that war. We have come to dedicate a portion of that "
      "field, as a final resting place for those who here gave their lives that "
      "that nation might live. It is altogether fitting and proper that we should do this.\n\n"
      "But, in a larger sense, we can not dedicateâwe can not consecrateâwe "
      "can not hallowâthis ground. The brave men, living and dead, who struggled here, "
      "have consecrated it, far above our poor power to add or detract. The world "
      "will little note, nor long remember what we say here, but it can never forget "
      "what they did here. It is for us the living, rather, to be dedicated here to "
      "the unfinished work which they who fought here have thus far so nobly advanced. "
      "It is rather for us to be here dedicated to the great task remaining before usâthat "
      "from these honored dead we take increased devotion to that cause for which they gave "
      "the last full measure of devotionâthat we here highly resolve that these dead shall"
      "not have died in vainâthat this nation, under God, shall have a new birth of "
      "freedomâand that government of the people, by the people, for the people, shall "
      "not perish from the earth.\n\n"
      "  âAbraham Lincoln"};
  std::string longGermanString{
      "Vor vier und sieben Jahren brachten unsere VÃ¤ter \n"
      "\nâAuf diesem Kontinent eine neue Nation, in Freiheit gezeugt und geweiht "
      "zu der Aussage, dass alle Menschen gleich geschaffen sind.\n\n"
      "\nâJetzt sind wir in einen groÃen BÃ¼rgerkrieg verwickelt und testen, ob diese Nation oder "
      "irgendeine "
      "Nation, die so konzipiert und so engagiert ist, kann lange bestehen. Wir treffen uns auf "
      "einem "
      "groÃes Schlachtfeld dieses Krieges. Wir sind gekommen, um einen Teil davon zu widmen "
      "\nâFeld, als letzte RuhestÃ¤tte fÃ¼r die, die hier ihr Leben gaben "
      "diese Nation kÃ¶nnte leben. Es ist absolut passend und angemessen, dass wir dies tun "
      "sollten.\n\n"
      "\nâAber im weiteren Sinne kÃ¶nnen wir uns nicht weihen â wir kÃ¶nnen uns nicht weihen "
      "\nâkann diesen Boden nicht heiligen. Die tapferen MÃ¤nner, lebend und tot, die hier gekÃ¤mpft "
      "haben. "
      "haben es geweiht, weit Ã¼ber unserer armen Macht hinzuzufÃ¼gen oder zu schmÃ¤lern. Die Welt "
      "\nâWerde wenig merken und sich nicht lange daran erinnern, was wir hier sagen, aber er kann "
      "es nie vergessen "
      "\nâwas sie hier getan haben. Es ist vielmehr fÃ¼r uns Lebende, sich hier zu widmen. "
      "\nâdas unvollendete Werk, das sie, die hier gekÃ¤mpft haben, bisher so edel vorangebracht "
      "haben. "
      "\nâEs liegt vielmehr an uns, hier der groÃen Aufgabe gewidmet zu sein, die vor uns liegt â "
      "dass \nâ"
      "\nâVon diesen geehrten Toten nehmen wir eine verstÃ¤rkte Hingabe an die Sache, fÃ¼r die sie "
      "gaben "
      "das letzte volle MaÃ an Hingabe - dass wir hier hochentschlossen sind, dass diese Toten es "
      "tun werden "
      "nicht umsonst gestorben sind - dass diese Nation unter Gott eine neue Geburt haben wird "
      "\nâFreiheit â und diese Regierung des Volkes durch das Volk fÃ¼r das Volk soll "
      "nicht von der Erde vergehen.\n\n"
      "  -Abraham Lincoln"};
  std::string longUkranianString{
      "Ð§Ð¾ÑÐ¸ÑÐ¸ ÑÐ°ÑÑÐ½ÐºÐ¸ Ñ ÑÑÐ¼ ÑÐ¾ÐºÑÐ² ÑÐ¾Ð¼Ñ Ð½Ð°ÑÑ Ð±Ð°ÑÑÐºÐ¸ Ð¿ÑÐ¸Ð½ÐµÑÐ»Ð¸Â» "
      "Ð½Ð° ÑÑÐ¾Ð¼Ñ ÐºÐ¾Ð½ÑÐ¸Ð½ÐµÐ½ÑÑ Ð½Ð¾Ð²Ð° Ð½Ð°ÑÑÑ, Ð·Ð°ÑÐ°ÑÐ° Ð² Ð¡Ð²Ð¾Ð±Ð¾Ð´Ñ ÑÐ° Ð¿ÑÐ¸ÑÐ²ÑÑÐµÐ½Ð° "
      "Ð´Ð¾ Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð½Ñ Ð¿ÑÐ¾ ÑÐµ, ÑÐ¾ Ð²ÑÑ Ð»ÑÐ´Ð¸ ÑÑÐ²Ð¾ÑÐµÐ½Ñ ÑÑÐ²Ð½Ð¸Ð¼Ð¸.\n\n"
      "Â«ÐÐ°ÑÐ°Ð· Ð¼Ð¸ Ð±ÐµÑÐµÐ¼Ð¾ ÑÑÐ°ÑÑÑ Ñ Ð²ÐµÐ»Ð¸ÐºÑÐ¹ Ð³ÑÐ¾Ð¼Ð°Ð´ÑÐ½ÑÑÐºÑÐ¹ Ð²ÑÐ¹Ð½Ñ, Ð¿ÐµÑÐµÐ²ÑÑÑÑÑÐ¸, ÑÐ¸ ÑÑ Ð½Ð°ÑÑÑ, ÑÐ¸ "
      "Ð±ÑÐ´Ñ-ÑÐºÐ°Â» "
      "Ð½Ð°ÑÑÑ, ÑÐºÐ° ÑÐ°Ðº Ð·Ð°Ð´ÑÐ¼Ð°Ð½Ð° Ñ Ð½Ð°ÑÑÑÐ»ÑÐºÐ¸ Ð²ÑÐ´Ð´Ð°Ð½Ð°, Ð¼Ð¾Ð¶Ðµ Ð´Ð¾Ð²Ð³Ð¾ Ð²Ð¸ÑÑÐ¸Ð¼Ð°ÑÐ¸. ÐÐ°Ñ Ð·ÑÑÑÑÑÐ»Ð¸ Ð½Ð° "
      "Â«Ð²ÐµÐ»Ð¸ÐºÐµ Ð¿Ð¾Ð»Ðµ Ð±Ð¸ÑÐ²Ð¸ ÑÑÑÑ Ð²ÑÐ¹Ð½Ð¸. ÐÐ¸ Ð¿ÑÐ¸Ð¹ÑÐ»Ð¸, ÑÐ¾Ð± Ð¿ÑÐ¸ÑÐ²ÑÑÐ¸ÑÐ¸ ÑÐ°ÑÑÐ¸Ð½Ñ ÑÑÐ¾Ð³Ð¾Â» "
      "Â«Ð¿Ð¾Ð»Ðµ, ÑÐº Ð¼ÑÑÑÐµ Ð¾ÑÑÐ°Ð½Ð½ÑÐ¾Ð³Ð¾ ÑÐ¿Ð¾ÑÐ¸Ð½ÐºÑ ÑÐ¸Ñ, ÑÑÐ¾ ÑÑÑ Ð²ÑÐ´Ð´Ð°Ð² ÑÐ²Ð¾Ñ Ð¶Ð¸ÑÑÑ, ÑÐ¾Â» "
      "ÑÐ° Ð½Ð°ÑÑÑ Ð¼Ð¾Ð¶Ðµ Ð¶Ð¸ÑÐ¸. Ð¦ÑÐ»ÐºÐ¾Ð¼ Ð´Ð¾ÑÐµÑÐ½Ð¾ Ñ Ð½Ð°Ð»ÐµÐ¶Ð½Ð¾, ÑÐ¾Ð± Ð¼Ð¸ ÑÐµ Ð·ÑÐ¾Ð±Ð¸Ð»Ð¸.\n\n "
      "Â«ÐÐ»Ðµ Ð² Ð±ÑÐ»ÑÑ ÑÐ¸ÑÐ¾ÐºÐ¾Ð¼Ñ ÑÐµÐ½ÑÑ Ð¼Ð¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÐ¼Ð¾ Ð¿ÑÐ¸ÑÐ²ÑÑÐ¸ÑÐ¸âÐ¼Ð¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÐ¼Ð¾ Ð¾ÑÐ²ÑÑÐ¸ÑÐ¸âÐ¼Ð¸Â» "
      "Â«Ð½Ðµ Ð¼Ð¾Ð¶Ñ Ð¾ÑÐ²ÑÑÐ¸ÑÐ¸âÑÑ Ð·ÐµÐ¼Ð»Ñ. ÐÑÐ´Ð²Ð°Ð¶Ð½Ñ Ð»ÑÐ´Ð¸, Ð¶Ð¸Ð²Ñ Ð¹ Ð¼ÐµÑÑÐ²Ñ, ÑÐºÑ Ð±Ð¾ÑÐ¾Ð»Ð¸ÑÑ ÑÑÑ,Â» "
      "Â«Ð¾ÑÐ²ÑÑÐ¸Ð»Ð¸ Ð¹Ð¾Ð³Ð¾, Ð½Ð°Ð±Ð°Ð³Ð°ÑÐ¾ Ð²Ð¸ÑÐµ Ð½Ð°ÑÐ¾Ñ Ð±ÑÐ´Ð½Ð¾Ñ ÑÐ¸Ð»Ð¸ Ð´Ð¾Ð´Ð°ÑÐ¸ Ð°Ð±Ð¾ Ð¿ÑÐ¸Ð¼ÐµÐ½ÑÐ¸ÑÐ¸. Ð¡Ð²ÑÑÂ» "
      "Ð±ÑÐ´Ðµ Ð¼Ð°Ð»Ð¾ Ð¿Ð°Ð¼'ÑÑÐ°ÑÐ¸, Ð½Ñ Ð´Ð¾Ð²Ð³Ð¾ Ð¿Ð°Ð¼'ÑÑÐ°ÑÐ¸, ÑÐ¾ Ð¼Ð¸ ÑÑÑ Ð³Ð¾Ð²Ð¾ÑÐ¸Ð¼Ð¾, Ð°Ð»Ðµ ÑÐµ Ð½ÑÐºÐ¾Ð»Ð¸ Ð½Ðµ Ð¼Ð¾Ð¶Ð½Ð° Ð·Ð°Ð±ÑÑÐ¸ "
      "ÑÐ¾ Ð²Ð¾Ð½Ð¸ Ð·ÑÐ¾Ð±Ð¸Ð»Ð¸ ÑÑÑ. Ð¦Ðµ Ð´Ð»Ñ Ð½Ð°Ñ, Ð¶Ð¸Ð²Ð¸Ñ, ÑÐºÐ¾ÑÑÑÐµ, ÑÐ¾Ð± Ð±ÑÑÐ¸ ÑÑÑ Ð¿ÑÐ¸ÑÐ²ÑÑÐµÐ½Ñ "
      "Â«Ð½ÐµÐ·Ð°Ð²ÐµÑÑÐµÐ½Ð° ÑÐ¾Ð±Ð¾ÑÐ°, ÑÐºÑ ÑÑ, ÑÑÐ¾ ÑÑÑ Ð²Ð¾ÑÐ²Ð°Ð², ÑÐ°Ðº ÑÐ»ÑÑÐµÑÐ½Ð¾ Ð¿ÑÐ¾ÑÑÐ½ÑÐ»Ð¸ Ð²Ð¿ÐµÑÐµÐ´Â». "
      "Â«ÐÐ°Ð¼ ÐºÑÐ°ÑÐµ Ð±ÑÑÐ¸ ÑÑÑ, Ð¿ÑÐ¸ÑÐ²ÑÑÐµÐ½Ð¸Ð¼ Ð²ÐµÐ»Ð¸ÐºÐ¾Ð¼Ñ Ð·Ð°Ð²Ð´Ð°Ð½Ð½Ñ, ÑÐºÐµ ÑÑÐ¾ÑÑÑ Ð¿ÐµÑÐµÐ´ Ð½Ð°Ð¼Ð¸,â "
      "Ð²ÑÐ´ ÑÐ¸Ñ Ð¿Ð¾ÑÐµÑÐ½Ð¸Ñ Ð¼ÐµÑÑÐ²Ð¸Ñ Ð¼Ð¸ Ð±ÐµÑÐµÐ¼Ð¾ Ð±ÑÐ»ÑÑÑ Ð²ÑÐ´Ð´Ð°Ð½ÑÑÑÑ ÑÑÐ¹ ÑÐ¿ÑÐ°Ð²Ñ, Ð·Ð° ÑÐºÑ Ð²Ð¾Ð½Ð¸ Ð²ÑÐ´Ð´Ð°Ð»Ð¸ "
      "Â«Ð¾ÑÑÐ°Ð½Ð½Ñ Ð¿Ð¾Ð²Ð½Ð° Ð¼ÑÑÐ° Ð²ÑÐ´Ð´Ð°Ð½Ð¾ÑÑÑ â ÑÐ¾ Ð¼Ð¸ ÑÑÑ ÑÐ²ÐµÑÐ´Ð¾ Ð¿Ð¾ÑÑÐ°Ð½Ð¾Ð²Ð¸Ð»Ð¸, ÑÐ¾ ÑÑ Ð¼ÐµÑÑÐ²Ñ Ð±ÑÐ´ÑÑÑÂ» "
      "Â«Ð½Ðµ Ð¿Ð¾Ð¼ÐµÑÐ»Ð¸ Ð´Ð°ÑÐµÐ¼Ð½Ð¾ â ÑÐ¾ ÑÑ Ð½Ð°ÑÑÑ, Ð¿ÑÐ´ ÐÐ¾Ð³Ð¾Ð¼, Ð¼Ð°ÑÐ¸Ð¼Ðµ Ð½Ð¾Ð²Ðµ Ð½Ð°ÑÐ¾Ð´Ð¶ÐµÐ½Ð½ÑÂ» "
      "ÑÐ²Ð¾Ð±Ð¾Ð´Ð° - Ñ ÑÐµÐ¹ ÑÑÑÐ´ Ð½Ð°ÑÐ¾Ð´Ñ, Ð½Ð°ÑÐ¾Ð´Ð¾Ð¼, Ð´Ð»Ñ Ð½Ð°ÑÐ¾Ð´Ñ, Ð±ÑÐ´Ðµ "
      "Ð½Ðµ Ð·Ð³Ð¸Ð½ÑÑÐ¸ ÑÐ· Ð·ÐµÐ¼Ð»Ñ.\n\n"
      "  -ÐÐ±ÑÐ°ÑÐ°Ð¼ ÐÑÐ½ÐºÐ¾Ð»ÑÐ½"};
  std::string longJapanseString{
      "4 ç¹ã¨ 7 å¹´åã«ç§ãã¡ã®ç¶è¦ªãæã£ã¦ããã "
      "ããã®å¤§é¸ã«åºã¦ãèªç±ã®ä¸­ã§çã¾ããç®èº«ããæ°ããå½ã "
      "ããã¹ã¦ã®äººéã¯å¹³ç­ã«ä½ããã¦ããã¨ããå½é¡ã«ã\n\nã "
      "ãä»ãç§ãã¡ã¯å¤§è¦æ¨¡ãªåæ¦ã«å¾äºãã¦ããããã®å½ãã¾ãã¯ä»ã®å½ãã©ããããã¹ããã¦ãã¾ãã "
      "ããã®ããã«æ§æ³ãããç®èº«çãªå½ã¯ãé·ãèãããã¨ãã§ãã¾ããç§ãã¡ã¯ã "
      "ããã®æ¦äºã®åå¤§ãªæ¦å ´ãæãã¯ãã®ä¸é¨ãæ§ããããã«æ¥ãã "
      "ãéåã¯ããã§å½ãè½ã¨ããäººãã®æ°¸ç ã®å°ã "
      "ããã®å½ã¯çãã¦ããããããã¾ãããç§ãã¡ããããè¡ãã®ã¯ãã¾ã£ããé©åã§é©åãªãã¨ã§ãã\n"
      "\nã "
      "ãããããããå¤§ããªæå³ã§ãç§ãã¡ã¯ç®èº«ãããã¨ã¯ã§ãã¾ããâå¥ç®ãããã¨ã¯ã§ãã¾ããâç§ãã¡"
      "ã¯ã "
      "ãç¥èåã§ããªãââãã®å¤§å°ãçæ­»ãåãããããã§å¥®éããåèãã¡ã "
      "ãç§ãã¡ã®è²§ããåãå ãããæ¸ããããããåãã¯ããã«è¶ãã¦ããããå¥ç®ãã¾ãããä¸çã "
      "ãããã§ç§ãã¡ãè¨ã£ããã¨ãã»ã¨ãã©è¦ãã¦ããªãããé·ãè¦ãã¦ãã¾ããããæ±ºãã¦å¿ãããã¨ã¯"
      "ã§ãã¾ããã "
      "ãå½¼ããããã§ä½ãããããããããããã§ç®èº«ããã®ã¯ç§ãã¡ã®å½ã§ãã "
      "ãããã§æ¦ã£ãå½¼ããããã¾ã§æ°é«ãé²ãã¦ããæªå®ã®ä»äºãã "
      "ãç§ãã¡ãããã«ããã®ã¯ãç§ãã¡ã®åã«æ®ã£ã¦ããå¤§ããªä»äºã«å°å¿µããããã§ããããã¯ã "
      "ããããã®åèªããæ­»èãããç§ãã¡ã¯å½¼ããä¸ããå¤§ç¾©ã¸ã®ãããªãç®èº«ãåãã¾ãã "
      "ãç®èº«ã®æå¾ã®å®å¨ãªå°ºåº¦âããã§ç§ãã¡ã¯ãããã®æ­»èãããããã§ããããã¨ãå¼·ãæ±ºæãã¾ãã "
      "ãç¡é§ã«æ­»ãã ã®ã§ã¯ãªãããã®å½ãç¥ã®ä¸ã§æ°ãã«èªçããããã«ã "
      "ãèªç±ãããã¦äººæ°ã®ãäººæ°ã«ãããäººæ°ã®ããã®æ¿åºã¯ã "
      "ãå°çããæ»ã³ãªãã§ã\n\nã "
      "  -ã¢ãã©ãã ãªã³ã«ã¼ã³"};

  // int oneHundredThousand = 100000;
  int twentyThousand = 20000;
  int iterations = twentyThousand;
  int aggregateUnicodeConverterTime = 0;
  int aggregateCharsetConverterTime = 0;
  int expectedImprovement = 0;
  bool printGroupSummary = REPORT_PERFORMANCE_DETAILS;
  bool endGroup = true;
  expectedImprovement = 25; // Actual 54%
  int actualShortStringImprovment;
  runTest(iterations, "Short English  ", shortString, expectedImprovement,
          actualShortStringImprovment, aggregateUnicodeConverterTime,
          aggregateCharsetConverterTime);
  runTest(iterations, "Short German   ", shortGermanString, expectedImprovement,
          actualShortStringImprovment, aggregateUnicodeConverterTime,
          aggregateCharsetConverterTime);
  runTest(iterations, "Short Ukranian ", shortUkranianString, expectedImprovement,
          actualShortStringImprovment, aggregateUnicodeConverterTime,
          aggregateCharsetConverterTime);
  runTest(iterations, "Short Japanese ", shortJapaneseString, expectedImprovement,
          actualShortStringImprovment, aggregateUnicodeConverterTime, aggregateCharsetConverterTime,
          endGroup, printGroupSummary);

  aggregateUnicodeConverterTime = 0;
  aggregateCharsetConverterTime = 0;
  expectedImprovement = 15; // Actual 37%
  int actualMediumStringImprovement;
  runTest(iterations, "Medium English ", mediumString, expectedImprovement,
          actualMediumStringImprovement, aggregateUnicodeConverterTime,
          aggregateCharsetConverterTime);
  runTest(iterations, "Medium German  ", mediumGermanString, expectedImprovement,
          actualMediumStringImprovement, aggregateUnicodeConverterTime,
          aggregateCharsetConverterTime);
  runTest(iterations, "Medium Ukranian", mediumUkranianString, expectedImprovement,
          actualMediumStringImprovement, aggregateUnicodeConverterTime,
          aggregateCharsetConverterTime);
  runTest(iterations, "Medium Japanese", mediumJapaneseString, expectedImprovement,
          actualMediumStringImprovement, aggregateUnicodeConverterTime,
          aggregateCharsetConverterTime, endGroup, printGroupSummary);

  aggregateUnicodeConverterTime = 0;
  aggregateCharsetConverterTime = 0;
  expectedImprovement = 0; // Actual 6%
  int actualLongStringImprovement;
  runTest(iterations, "Long English   ", longString, expectedImprovement,
          actualLongStringImprovement, aggregateUnicodeConverterTime,
          aggregateCharsetConverterTime);
  runTest(iterations, "Long German    ", longGermanString, expectedImprovement,
          actualLongStringImprovement, aggregateUnicodeConverterTime,
          aggregateCharsetConverterTime);
  runTest(iterations, "Long Ukranian  ", longUkranianString, expectedImprovement,
          actualLongStringImprovement, aggregateUnicodeConverterTime,
          aggregateCharsetConverterTime);
  runTest(iterations, "Long Japanese  ", longJapanseString, expectedImprovement,
          actualLongStringImprovement, aggregateUnicodeConverterTime, aggregateCharsetConverterTime,
          endGroup, printGroupSummary);

  std::cout << std::endl;

  int overallImprovment =
      (actualShortStringImprovment + actualMediumStringImprovement + actualLongStringImprovement) /
      3;

  int totalMicros = aggregateUnicodeConverterTime + aggregateCharsetConverterTime;
  std::string totalMillisStr = FormatWithCommas(totalMicros / 1000);
  std::string aggregateUnicodeConverteTimeStr =
      FormatWithCommas(aggregateUnicodeConverterTime / 1000);
  std::string aggregateCharsetConverterConverterTimeStr =
      FormatWithCommas(aggregateCharsetConverterTime / 1000);
  int percentImprovement =
      100 - ((aggregateUnicodeConverterTime * 100) / aggregateCharsetConverterTime);
  std::string pctDiffOverall = FormatWithCommas(percentImprovement);
  std::string pctDiffByGroup = FormatWithCommas(overallImprovment);
  if (REPORT_PERFORMANCE_DETAILS)
  {
    std::cout << "UnicodeConverter total time: " << aggregateUnicodeConverteTimeStr << "ms "
              << " CharsetConverter total time: " << aggregateCharsetConverterConverterTimeStr
              << "ms" << std::endl;
    std::cout << "UnicodeConverter is " << pctDiffOverall
              << "% faster than CharsetConverter overall" << std::endl;
    std::cout << pctDiffByGroup << "% faster by group (above number over-represents long strings)"
              << std::endl;
  }
  // Test passes if UnicodeConverter is faster than CharsetConverter.
  // UnicodeConverter should be about 55% faster than CharSetConveter for short strings
  // Long strings should be about 5% faster

  EXPECT_GE(percentImprovement, 0); // Minimum 0% improvement to pass
}

void runTest(int iterations,
             std::string_view title,
             std::string_view text,
             int expectedImprovement,
             int& actualImprovement,
             int& aggregateUnicodeConverterTime,
             int& aggregateCharsetConverterTime,
             bool endGroup, // = false,
             bool printSummary) //  = false)
{
  int scale = 100000; // / 1000; // To calculate code units / ms
  std::string iterationsStr = FormatWithCommas(iterations);
  std::chrono::time_point<std::chrono::steady_clock> start_time = std::chrono::steady_clock::now();
  std::chrono::steady_clock::time_point test_case_start;

  std::string unicodeConverterTitle("UnicodeConverter ");
  unicodeConverterTitle.append(title);
  std::string charsetConverterTitle("CharsetConverter ");
  charsetConverterTitle.append(title);
  int unicodeConverterTotalTime{0};
  int charsetConverterTotalTime{0};

  // First set of tests is with NEW CUnicodeConverter
  // - utf8->utf32
  // - utf32->utf8
  // - utf8->wstring

  test_case_start = std::chrono::steady_clock::now();
  std::u32string u32Result;
  for (int i = 0; i < iterations; i++)
  {
    u32Result = CUnicodeConverter::Utf8ToUtf32(text);
  }
  std::chrono::time_point<std::chrono::steady_clock> stop_time = std::chrono::steady_clock::now();
  int micros_1 =
      std::chrono::duration_cast<std::chrono::microseconds>(stop_time - test_case_start).count();
  unicodeConverterTotalTime += micros_1;

  test_case_start = std::chrono::steady_clock::now();
  std::string utf8Result;
  for (int i = 0; i < iterations; i++)
  {
    utf8Result = CUnicodeConverter::Utf32ToUtf8(u32Result);
  }
  stop_time = std::chrono::steady_clock::now();
  int micros_2 =
      std::chrono::duration_cast<std::chrono::microseconds>(stop_time - test_case_start).count();
  unicodeConverterTotalTime += micros_2;

  test_case_start = std::chrono::steady_clock::now();
  std::wstring wcharResult;
  for (int i = 0; i < iterations; i++)
  {
    wcharResult = CUnicodeConverter::Utf8ToW(text);
  }
  stop_time = std::chrono::steady_clock::now();
  int micros_3 =
      std::chrono::duration_cast<std::chrono::microseconds>(stop_time - test_case_start).count();
  unicodeConverterTotalTime += micros_3;
  aggregateUnicodeConverterTime += unicodeConverterTotalTime;

  // Using CCharsetConverter

  start_time = std::chrono::steady_clock::now();
  test_case_start = std::chrono::steady_clock::now();
  for (int i = 0; i < iterations; i++)
  {
    std::string stringConversion{text};
    u32Result = CCharsetConverter::utf8ToUtf32(stringConversion);
  }
  stop_time = std::chrono::steady_clock::now();
  int micros_4 =
      std::chrono::duration_cast<std::chrono::microseconds>(stop_time - test_case_start).count();
  charsetConverterTotalTime += micros_4;

  test_case_start = std::chrono::steady_clock::now();
  std::u32string_view u32sv(u32Result);
  for (int i = 0; i < iterations; i++)
  {
    std::u32string tmp{u32sv};
    utf8Result = CCharsetConverter::utf32ToUtf8(tmp);
  }
  stop_time = std::chrono::steady_clock::now();
  int micros_5 =
      std::chrono::duration_cast<std::chrono::microseconds>(stop_time - test_case_start).count();
  charsetConverterTotalTime += micros_5;

  test_case_start = std::chrono::steady_clock::now();
  for (int i = 0; i < iterations; i++)
  {
    std::string stringConversion{text};
    std::wstring wcharResult;
    CCharsetConverter::utf8ToW(stringConversion, wcharResult, false);
  }
  stop_time = std::chrono::steady_clock::now();
  int micros_6 =
      std::chrono::duration_cast<std::chrono::microseconds>(stop_time - test_case_start).count();

  charsetConverterTotalTime += micros_6;
  aggregateCharsetConverterTime += charsetConverterTotalTime;
  std::string millisStr;

  if (REPORT_PERFORMANCE_DETAILS)
  {
    millisStr = FormatWithCommas(micros_1 / 1000);
    std::cout << unicodeConverterTitle << " Utf8ToUtf32 " << millisStr << "ms "
              << (text.length() * scale) / micros_1 << " code-units/ms for " << iterationsStr
              << " iterations" << std::endl;

    millisStr = FormatWithCommas(micros_2 / 1000);
    std::cout << unicodeConverterTitle << " Utf32ToUtf8 " << millisStr << "ms "
        << (text.length() * scale) / micros_2 << " code-units/ms for " << iterationsStr
        << " iterations" << std::endl;

    millisStr = FormatWithCommas(micros_3 / 1000);
    std::cout << unicodeConverterTitle << " Utf8ToW     " << millisStr << "ms "
        << (text.length() * scale) / micros_3 << " code-units/ms for " << iterationsStr
        << " iterations" << std::endl;

    // millisStr = FormatWithCommas(unicodeConverterTotalTime/1000);
    //std::cout << unicodeConverterTitle << "Total       " << millisStr << "ms for " << iterationsStr
    //             << " iterations" << std::endl;
    std::cout << std::endl;

    millisStr = FormatWithCommas(micros_4/1000);
    std::cout << charsetConverterTitle << " Utf8ToUtf32 " << millisStr << "ms "
        << (text.length() * scale) / micros_4 << " code-units/ms for "
        << iterationsStr << " iterations" << std::endl;

    millisStr = FormatWithCommas(micros_5/1000);
    std::cout << charsetConverterTitle << " Utf32ToUtf8 " << millisStr << "ms "
        << (text.length() * scale) / micros_5 << " code-units/ms for "
        << iterationsStr << " iterations" << std::endl;

    millisStr = FormatWithCommas(micros_6/1000);
    std::cout << charsetConverterTitle << " Utf8ToW     " << millisStr << "ms "
        << (text.length() * scale) / micros_6 << " code-units/ms for "
        << iterationsStr << " iterations" << std::endl;

    std::cout << std::endl;
  }
  if (endGroup)
  {
    std::string unicodeConverterTotalStr = FormatWithCommas(unicodeConverterTotalTime / 1000);
    std::string charsetConverterTotalStr = FormatWithCommas(charsetConverterTotalTime/1000);
    int totalMicros = unicodeConverterTotalTime + charsetConverterTotalTime;
    std::string totalMillisStr = FormatWithCommas(totalMicros/1000);
    int percentImprovement = 100 - ((unicodeConverterTotalTime * 100) / charsetConverterTotalTime);
    actualImprovement = percentImprovement;
    std::string pctDiff = FormatWithCommas(percentImprovement);
    if (printSummary)
    {
      std::cout << unicodeConverterTitle << " total time: " << unicodeConverterTotalStr << "ms " << std::endl;
      std::cout << charsetConverterTitle << " total time: " << charsetConverterTotalStr << "ms" << std::endl;
      std::cout << "UnicodeConverter is " << pctDiff << "% faster than CharsetConverter" << std::endl << std::endl;
    }
    EXPECT_GE(percentImprovement, expectedImprovement);
  }
}
} // namespace
